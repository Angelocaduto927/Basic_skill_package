/*
继承  面向对象三大特性之一（减少重复代码）
定义类的时候，下级别成员除了拥有上一级的共性，还有自己的特性


    1.语法：
    Class father_name
    {
    public:
        只写公共的函数
    };
    Class son_name : public father_name   //public是继承方式，还有其他的继承方式
    {
    public:
        只写自己独特的函数
    };
    //子类：也叫派生类； 父类：也叫基类
    //派生类中的成员包含两大部分：1.从基类继承过来的；2.自己增加的成员



    2.继承方式    class 子类 : 继承方式 父类
    一共三种
        1.公共继承   a.父类中的公共属性在子类中仍然公共，且可以访问   b.父类中的保护属性在子类中仍然保护，且可以访问   c.父类中的私有属性子类无法访问
        2.保护继承   a.父类中的公共属性在子类中变为保护，且可以访问   b.父类中的保护属性在子类中仍然保护，且可以访问   c.父类中的私有属性子类无法访问
        3.私有继承   a.父类中的公共属性在子类中变为私有，且可以访问   b.父类中的保护属性在子类中变为私有，且可以访问   c.父类中的私有属性子类无法访问



    3.继承中的对象模型
    问题：从父类继承过来的成员，到底属不属于子类的对象？    都属于
        Class base
        {
        public:
            int m_a;
        protected:
            int m_b;
        private:
            int m_c;
        };
        class son : public base
        {
        public:
            int m_d;
        };
        int main()
        {
            son s;
            cout << sizeof(s) <<endl;  //输出16  1.父类中所有非静态成员属性都会被子类继承下去  2.父类中私有成员属性是被编译器给隐藏了，因此是访问不到但是确实被继承下去了
        }

        //父类中的非静态成员属性每个子类对象都会拷贝一份，互不影响，但是静态成员属性就不会拷贝，而是通过地址访问，所以所有对象拥有同一个静态成员属性

        //开发人员命令提示符查看class内部分布
        1.首先在菜单找到开发人员命令提示符
        2.跳转到文件所在目录
        3.用代码 cl /d1 reportSingleClassLayoutClass_name "代码文件名"
        4.输出这个类中的继承和属性对象分布




    4.继承中的构造和析构顺序   子类继承父类后，创建子类对象也会调用父类的构造函数
        父类先构造，子类再构造；子类先析构，父类再析构
        （和class里面套class的顺序一样）




    5.继承同名成员处理方式  子类与父类出现同名的成员时，如何通过子类对象访问到子类或者父类中的同名数据
        1.访问子类同名成员，直接访问即可
        2.访问父类同名成员，需要加作用域

        Class base
        {
        public:
            base()
            {
                m_a = 100;
            }
            int m_a;
            void func()
            {
                cout << "父类中的函数" << endl;
            }
        };
        Class son : public base
        {
        public:
            son()
            {
                m_a = 200;
            }
            int m_a;
            void func()
            {
                cout << "子类中的函数" << endl;
            }
        };
        int main()
        {
            son s;
            cout << s.m_a <<endl; //输出200，子类的m_a
            cout << s.base::m_a << endl;  //输出100， 父类的m_a
            s.func(); //访问的是子类的函数
            s.base::func();  //访问的是父类的函数

            //如果父类的函数是重载过的，比如 void func(int a)
            s.func(10); 依然会报错，不能这样访问
            //原因，只要子类和父类中出现了函数名一样的函数，不管是否重载，父类中的所有同名函数都会被子类隐藏掉，也就是无法直接访问
            //如果想要访问到父类中被隐藏的同名成员函数，都需要加作用域
            s.base::func(10); 正确，不报错
        }


    6.继承中同名静态成员处理方式
        继承中同名的静态成员在子类对象上如何进行访问？
        与非静态成员出现同名的处理方式一样
            1.通过对象访问
                ·访问子类同名成员，直接访问即可    s.m_a
                ·访问父类同名成员，需要加作用域    s.base::
            2.直接通过类名访问  //因为静态成员函数一定会被初始化且每个类的静态变量是唯一的，所以可以不用具体的对象，用类名就可以访问；非静态的就不可以，因为不同对象不一样，函数内操作也不一样
                ·son::m_a 通过类名访问son的m_a
                ·son::base::m_a 通过类名访问base作用域下的m_a
        //只要子类和父类中出现了函数名一样的成员函数（无论静态还是非静态），不管是否重载，父类中的所有同名函数（无论静态非静态）都会被子类隐藏掉，也就是无法直接访问



    7.多继承语法  C++允许一个类继承多个类
        语法：class 子类 : 继承方式 父类1， 继承方式 父类2 ...
        多继承可能引发父类中有同名成员的出现，需要加作用域区分
        实际开发中不建议使用



    8.菱形继承（钻石继承）
        有两个派生类继承同一个基类
        又有某个类同时继承这两个派生类

        问题：
            1.羊继承了动物类的数据，比如说age；驼也继承了动物类的数据age；当羊驼使用age数据的时候会出现二义性，不知道要的是继承自羊的还是继承自驼的  -> 解决办法：写作用域
            2.羊驼继承了两份动物类的数据，但实际上我们只需要一份，资源浪费   ->  利用虚继承可以解决菱形继承问题
                在继承方式前面加个virtual
                class middle1 : virtual public base
                class middle2 : virtual public base
                class son : public middle1, public middle2
                base类被称为虚基类，这个时候会把菱形继承中的中间两个类的共同属性看作同一个，也就是修改羊类的age，羊驼的age会跟着修改；修改驼类的age，羊驼的age也会修改
                //羊驼这样只会有一个age属性，然后也可以通过s.m_a直接访问了，不需要再声明作用域，因为已经没有二义性了

            虚继承本质
                middle1, middle2只会从base中继承vbptr (virtual base pointer)，这是指针而不是数据，指向各自的vbtable（virtual base table）
                在各自的vbtable中，记录了一个数据偏移量
                比如：子类son中会有0号位从middle1中继承的vbptr，4号位从middle2中继承的vbptr，8号位自己的唯一的父类属性(age)
                vbptr1指向vbtable1，里面记录了偏移量8,所以当访问middle1::age时会从0号位向后偏移8位，到自己的唯一的属性age
                vbptr2指向vbtable2，里面记录了偏移量4,所以当访问middle2::age时会从4号位向后偏移4位，到自己的唯一的属性age
                这样对于son的对象就不会有两个age属性，只有一个唯一的属性，且无论时访问那个middle类最后都会指向这个属性

                e.g.
                son s;
                s.middle1::age = 18  //指向唯一的age并且修改为18
                s.middle2::age = 28  //指向唯一的age并且修改为28
                s.age , s.middle1::age , s.middle2::age  现在都是28因为都是同一个数据
*/

/*
多态   C++面向对象三大特性之一  （多种形态）
    1.基础概念

        分为两类
            1.静态多态： 函数重载 和 运算符重载属于静态多态，复用函数名
            2.动态多态：派生类和虚函数实现运行时多态

        静态多态和动态多态的区别
            1.静态多态的函数地址早绑定 - 编译阶段确定函数地址
            2.动态多态的函数地址晚绑定 - 运行阶段确定函数地址

            例子
            class Animal
            {
            public:
                //1.非多态写法
                void speak()
                {
                    cout << "动物在说话" << endl;
                }

                //2.多态虚函数写法
                virtual void speak()
                {
                    cout << "动物在说话" << endl;
                }
            };
            class Cat : public Animal
            {
            public:
                void speak()
                {
                    cout << "小猫在说话" << endl;
                }
            };
            class Dog : public Animal
            {
            public:
                void speak()
                {
                    cout << "小狗在说话" << endl;
                }
            };
            void dospeak(Animal & animal)
            {
                animal.speak()
            }
            int main()
            {
                Cat cat;
                dospeak(cat);

                Dog dog;
                dospeak(dog);
            }

            1.首先C++允许使用父类的指针指向子类的对象，不需要做强制转换，这被称为向上转型（Upcasting）。这种机制是实现多态的基础，而无需进行强制类型转换，只要继承关系满足即可。
            2.但是子类的指针无法直接指向父类，因为子类指针期望指向一个具有子类所有成员的对象
            3.如果不使用virtual关键字，dospeak函数中的animal.speak是一个函数地址早绑定，在编译阶段就已经确定了，因为是animal类调用的，所以确定的路径就是走animal里面的speak函数，无论传进来的是猫还是狗都是走animal
            4.当使用了virtual之后就变成了函数地址晚绑定，dospeak里面的调用只有在运行的时候才能确定，根据传进来的是猫还是狗，调用具体类的函数（不能提前确定，用一个接口根据具体传入具体调用）

            动态多态满足条件
                1.有继承关系
                2.子类重写父类的虚函数，animal里面有virtual speak，猫和狗里面写了一个一模一样的；和重载不一样，重载是要求形参列表不一样，重写是要求完全一样（返回值类型，函数名，参数列表）
                3.子类重写函数的时候，virtual可加可不加，但父类的虚函数必须加

            动态多态使用
                1.父类的指针或者引用指向子类对象



    2.动态原理分析
        1.在不使用virtual的时候，sizeof(Animal)是1，因为函数不属于对象，所以不在对象类里
        2.在使用了virtual之后，sizeof(Animal)就变成了4，原因是这个时候Animal类里面多了一个指针，指针在32位系统下一直占4个字节
        3.这个指针是vfptr(virtual function pointer，虚函数（表）指针)，它指向一个vftable（virtual function table），这个table里面存储的是虚函数的地址
        4.当子类继承父类的时候，会把所有的vfptr，vftable也一并拷贝下来
        5.但是当子类发生函数重写的时候，vftable里面的地址会变成新的子类的函数的地址，和父类的不一样了
        6.所以当函数调用的时候传入的是指向子类对象的指针的时候，他就会通过子类里的虚函数表指针找到对应的函数并执行，发生多态

        而如果不加virtual,代码会在编译的时候看到因为是基类的指针类型（Animal & animal）所以就直接决定调用基类的函数，即使子类重写了这个函数依然不会选择子类的函数


    3.纯虚函数和抽象类
        在多态中，通常父类中的虚函数的实现是毫无意义的，因为根本不会调用它，主要都是调用子类重写的内容，因此可以把虚函数改为纯虚函数

        纯虚函数语法： virtual 返回值类型 函数名 (参数列表) = 0;
        当类中有了纯虚函数，这个类也被称为抽象类

        抽象类的特点：
            1.无法实例化对象 无论在栈区还是堆区，因为抽象类的对象没有意义
            2.子类必须重写抽象类中的纯虚函数，否则也属于抽象类

        在父类中只写抽象的定义函数，以及功能函数；子类中重写定义函数，然后用一个父类指针指向子类，调用父类中的功能函数，然后功能函数中会使用子类中重写的定义函数


    4.虚析构和纯虚析构
        多态使用时，父类指针指向子类对象，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码,也就没有办法释放子类的堆区属性，造成内存泄漏
        解决方式：将父类中的析构函数改为虚析构或者纯虚析构

        虚析构和纯虚析构共性
            1.都可以解决父类指针释放子类对象
            2.都需要有具体的函数实现
        虚析构和纯虚析构的区别
            1.如果是纯虚析构，该类属于抽象类，无法实例化对象

        虚析构语法
            virtual ~类名(){代码}  //声明且实现

        纯析构语法语法
            virtual ~类名() = 0;   这样还只是一个函数的声明没有函数的实现，虚析构和纯虚析构都要求必须有函数实现所以还要写
                                    //原因是，如果父类中也有开辟到堆区的对象，那这个时候父类里的虚析构和纯虚析构就可以发挥作用释放内存了
            在类里面写
                virtual ~类名() = 0;  //声明
            在类外写
                类名::~类名()   //实现
                {
                    代码实现
                }
*/

/*
文件操作
程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放
通过文件可以将数据持久化
C++中对文件操作需要包含头文件<fstream>

文件类型分为两种
    1.文本文件  -文件以文本的ASCII码形式存储在计算机中     双击后可以用记事本等工具打开，以明文的形式存在可以看懂
    2.二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们

操作文件的三大类
    1.ofstream 写操作
    2.ifstream 读操作
    3.fstream 读写操作


文本文件
1.写文件步骤
    1.包含头文件
        #include<fstream>
    2.创建流对象
        ofstream ofs;
    3.打开文件
        ofs.open("文件路径"，打开方式)；
    4.写数据
        ofs << "写入的数据" << endl;  //文件流输出
    5.关闭文件
        ofs.close();


    打开方式
        ios::in 为读文件而打开文件
        ios::out 为写文件而打开文件
        ios::ate 初始位置：文件尾
        ios::app 追加方式写文件
        ios::trunc 如果文件存在先删除，再创建
        ios::binary 二进制方式

        注意：文件打开方式可以配合使用，利用|操作符
        例如 ios::ate | ios::out

2.读文件步骤
    1.包含头文件
        #include<fstream>
    2.创建流对象
        ifstream ifs;
    3.打开文件并判断文件是否打开成功
        ifs.open("文件路径"，打开方式)；  //打开方式和写文件的一样
        ifs.is_open(); 如果打开成功会返回true，如果没打开返回false
    4.读数据
        4种方式
    5.关闭文件
        ifs.close();


    读数据的方式
        1.提取符
        char buf[1024] = {0};
        while (ifs >> buf)  //>>是提取符，默认按照空白字符（空格，制表，换行）分割，然后把单词或者数据块传入buf中输出。 1.buf输出的时候没有空格和换行，需要自己加 2.如果有连着超过1024个字符的话会丢失
        {
            cout << buf << endl;
        }

        2. 流对象的getline函数
        char buf[1024] = {0};
        while (ifs.getline(buf, sizeof(buf)))  //ifs流的函数，整行读取保留空格，第一位是存储读取数据的数组，第二个是数组大小
        {
            cout<<buf<<endl;
        }
        3. 字符串读取输出
        string buf;
        while ( getline(ifs, buf) ) //C++标准库的全局函数，需要两个参数一个是输入流，一个是储存的string，获取一整行放入string中
        {
            cout << buf << endl;
        }
        4. 一个个字符的读取输出
        char c;
        while( (c = ifs.get()) != EOF)  //EOF是end of file 文件尾，读到了就自动结束循环
        {
            cout << c <<endl;
        }


二进制文件
以二进制的方式对文件进行读写操作时，打开方式要加上ios::binary
写文件
    二进制方式写文件主要利用流对象调用成员函数write
    函数原型 ostream& write(const char * buffer, int len);  //buffer写的数据的地址, len要写多长，然后指针就能自己往后走去读取
    解释： 字符指针buffer指向内存中一段储存空间，len是读写的字节数

    1.包含头文件
        #include<fstream>
    2.创建流对象
        ofstream ofs;
    3.打开文件
        ofs.open("文件路径"，打开方式)； //或者合并到第二步   ofstream ofs("文件路径",ios::out | ios::binary);
    4.写数据
        ofs.write(const char * ptr, len);
    5.关闭文件
        ofs.close();


    特殊之处：二进制文件不仅可以读入C++的基本类型比如int, double，还可以读入自己创建的类型
    class Person
    {
    public:
        char m_name[64];    写字符串的时候，建议使用char数组的方式，因为这是更底层的C的写法，如果用string的话容易出一些问题
        int m_age;
    };
    int main()
    {
        Person p = {“张三”，18};  //聚合初始化，在没有自定义任何构造函数的情况下（也就是只写了成员属性和成员函数的情况下），这个写法是合法的，会按照顺序给成员赋值
        ofstream ofs("text.txt", ios::out | ios::binary);
        ofs.write((const char *)&p , sizeof(p));   //重点：C++中，取址符&的作用是：取出地址并且把地址包装成一个指向给类型的指针，所以他的结果就是指针类型   int * p = &a，右边是一个自动包装的指针，左边是一个自己定义的指针，把右边的指针赋值给左边，然后你就可以用左边的来操作，但是右边的返回的指针因为没有名字是操作不了的
        //&p相当于取了指向p的指针，然后通过前面的括号强制改变类型变成char的；常量指针，指针指向的值不可修改，所以保证了写的内容不会变
        ofs.close();
    }


读文件
二进制方式读文件主要利用流对象调用成员函数read
函数原型  istream& read(char *buffer, int len);
解释：字符指针buffer指向内存中的一段储存空间，len是读写的字节数

    1.包含头文件
        #include<fstream>
    2.创建流对象
        ifstream ifs;
    3.打开文件并判断文件是否打开成功
        ifs.open("文件路径"，打开方式)；  //打开方式和写文件的一样
        ifs.is_open(); 如果打开成功会返回true，如果没打开返回false
    4.读数据
        ifs.read((char *)&a, len);
    5.关闭文件
        ifs.close();

    class Person
    {
    public:
        char m_name[64];
        int m_age;
    };
    int main()
    {
        ifstream ifs;
        ifs.open("text.txt", ios::in | ios::binary);
        if (!ifs.is_open)
        {
            cout << "打开失败";
            return;
        }

        Person p;
        ifs.read((char *)&p, sizeof(p));  //读到p里面去了，一个指向p的指针，它的内容需要可修改因为要读入，所以不加const
        ifs.close();
    }
*/

/*
exit(0); 功能是遇到就直接结束程序

C++中判断文件是否为空的方法
char ch;
ifs >> ch;  //用右移操作符向右读取一个字符
if (ifs.eof()) //如果右移读到的字符是文档结束字符，说明里面啥也没有为空  |  或者新创一个字符，(c = ifs.get()) == EOF也说明为空
{
    cout << "文件为空" << endl;
}

一行一行读取的操作
while(ifs >> id && ifs >> name && ifs >> did)    //右移运算符>>，会自动跳过空白字符(空格，制表，换行)并直到遇到非空字符，然后读取连续的非空字符赋值给对应的变量；这行代码的意思是，只有当连续三个非空字符段都有且类型是匹配的上的，说明ifs运行没有问题，为真
{
    num++;
}

在释放堆区数组之前，如果数组里面还有堆区的数据，要先把数组里面的堆区数据释放干净再去释放堆区数组
*/