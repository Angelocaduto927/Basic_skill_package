/* #include <iostream>
using namespace std;

int main()
{
    cout << "Hello, World!" << endl;

    system("pause");
    return 0;
} */

// 单行注释
// 快速行注释， crtl+/
// 快速块注释， shift+alt+A
/*
   多行注释
*/

/*
 变量， 数据类型 变量名 = 变量初始值;
 变量类型： 常变量
    1. 宏常量 #define 常量名 常量值 （定义在文件最上方）
    2. const 数据类型 常量名 = 常量值; （定义在函数内）
*/

/*
标识符命名规则
1. 不能是关键字
2. 只能包含字母、数字和下划线
3，第一个字符必须是字母或下划线
4，大小写区分
*/

// sizeof(数据类型/变量) 返回数据类型/变量所占字节数

/*
 变量类型： 变量
    1. 整型
            short -2^15 ~ 2^15-1  2字节   如果超出范围会回到最小值，因为二进制数字信号的原因
            int   -2^31 ~ 2^31-1  4字节
            long  -2^31 ~ 2^31-1  4字节 （在Linux下，32位的long是4字节，64位的long是8字节，因此大于等于int）
            long long   -2^63 ~ 2^63-1  8字节
            (int)十六进制 -> 强制转成十进制的数
    2. 浮点型
            float单精度  4字节 7位有效数字 （有效数字不是指小数部分，而是小数点前后非零数字的总和）
            1. float f = 3.14f;  // 一般float类型的浮点数后面加f（不加f的话，编译器看见小数点第一判断是double,然后再根据前面的float把他转换成单精度，会多一步操作；如果直接在后面加上一个f的话，编译器就会直接识别为float不会转换）
            2. float f = 3.14;   // double类型的浮点数
            double双精度  8字节 15-16有效数字
            //默认情况下，输出一个小数，会显示出6为有效数字，无论doubleh还是float

            科学计数法
                1. float f = 3.14e2; // 3.14*10^2
    3. 字符型 表示单个字符（用单引号），只占用有个一个字节，且并不是把字符本身放入到内存中储存，而是将对应的ASCII码放入到内存中储存
            char c = 'A';

            打印字符型变量对应的ASCII码
            cout << (int)c << endl; // 65，转成整型输出； A-65, a-97
    4. 转义字符
        换行\n, 制表符\t 一个制表符是8个位置, 反斜杠\\
    4. 字符串型
            1. 沿用C语言的字符串写法
                char 变量名[] = "字符串"; 一个空的中括号和一个双引号
            2. C++的字符串写法
                string 变量名 = "字符串"; 需要引入头文件 #include <string>
    5. 布尔型
            true(本质是1)， false（本质是0），只占用一个字节
            bool b = true;
            cout << b << endl; // 1
    6. 数组类型 int arr[5] = {1, 2, 3, 4, 5};
    7. 指针类型 int* p = &a;
*/

/*
数据的输入输出
1. cin >> 变量名; // 输入
    bool类型输入时，只要非0就是true，0就是false
2. 随机数生成:
    rand()%100 -> 随机生成0-99的数； 生成1-100 -> rand()%100 + 1  //但是很大可能是伪随机数
    //添加随机数种子，根据当前系统时间生成，防止每次都一样
    #include<ctime>
    srand((unsigned int)time(NULL));  //需要头文件 #include<ctime>
*/

/*
运算符
    算术运算符（前置递加/减【先自增再运算】： ++i,--i; 后置递加/减【先运算再自增】： i++,i--），（整数相除依然是整数，直接舍弃小数部分，除数不可为0），（两个小数相除得到整数或小数，两个小数不能做取余运算）
    赋值运算符 cout<<(a==b)<<endl;【先运算a==b，再输出】
    比较运算符 ！非，&&与，||或 【cout<<(a && b)<<endl;】
    位运算符  &按位与，|按位或，^按位异或，~按位取反，<<左移，>>右移
    逻辑运算符
*/

/*
程序流程结构
    顺序结构 略

    选择结构
        1. if else
            if(条件){
                // 如果if后的条件满足，执行
                // 语句1;
                // 语句2;
            }
            else if(条件){
                // 如果if后的条件不满足，else if后的条件满足，执行
                // 语句1;
                // 语句2;
            }
            else{
                // 如果if后的条件不满足，else if后的条件也不满足，执行
                // 语句1;
                // 语句2;
            }
        2. switch case   // switch后面只能是整型或字符型，case后面只能是整型或字符型，不可以是区间
            执行多条件分支语句
            switch(表达式/变量){
                case 结果1:
                    // 语句1;
                    break; // 跳出switch (不break的话，下面的case也会执行)
                case 结果2:
                    // 语句2;
                    break; // 跳出switch
                default:
                    // 如果没有匹配到任何case，执行default
                    // 语句3;
            }
            //注意如果case中的代码很短没有问题，但是如果很长他会报错，这个时候需要用两个花括号把那一长串代码括起来形成一个代码段，这样就不会报错

            switch(score){
                case 1:
                    cout << "优秀" << endl;
                    break;
                case 2:
                    cout << "良好" << endl;
                    break;
                default:
                    cout << "不及格" << endl;
            }
        3. 三目运算符 变量 = (条件) ? 表达式1 : 表达式2; // 如果条件成立，变量=表达式1，否则变量=表达式2
            c = (a > b) ? a : b; // 返回值更大的那个，且三目运算符返回的是变量可以继续赋值操作

    循环结构
        1. while （先判断条件再看要不要执行第一次循环）
            while(条件){
                // 语句1;
                // 语句2;
            }
        2. do while （先执行一次循环，再判断条件是否满足以及是否要再去循环第二次...）
            do{
                //语句1；
            }
            while(循环条件);
        3. for （起始表达式，条件表达式，末尾循环体都可以拆开分别写，用break退出整个for，用continue退出当前的for）
            for (起始表达式; 条件表达式; 末尾循环体){
                // 语句1;
            }
            for(int i = 0; i < 10; i++){
                // 语句1;
            }
*/

/*
跳转语句
    1. break 用于跳出选择结构或循环结构
        1. switch case 中，终止case并跳出switch
        2. 循环语句中，跳出当前的循环语句
        3. 嵌套循环中，跳出最近的内层循环语句
    2. continue 用于跳过本次循环中余下未执行的语句，进入下一次循环
    3. goto 用于无条件跳转到指定的标记处（如果标记的名称存在）
        1. goto 标签名; // 跳转到标签处
        2. 标签名: // 标签
            XXXXX
            XXXXX
            goto FLAG;
            XXXXX
            FLAG:
            XXXXX    会跳过一行
    4. return 用于结束函数，并返回值
*/

/*
数组 就是一个集合，里面存放了相同类型的数据元素，下表从0开始
    1. 相同数据元素
    2. 数组是由连续的内存位置组成的
一维数组的定义方式
    1. 数据类型 数组名[数组长度]; // 数组大小必须是常量表达式
    2. 数据类型 数组名[数组长度] = {元素1, 元素2, 元素3, ...}; // 数组长度由编译器自动计算，没有初始化的就赋值为0
    3. 数据类型 数组名[] = {元素1, 元素2, 元素3, ...}; // 数组长度由编译器自动计算
一维数组名称的用途
    1. 统计整个数组在内存中的长度
        sizeof(数组名) 统计整个数组的长度
        sizeof(数组名)/sizeof(数组名[0]) 统计数组中元素的个数
    2. 获取数组在内存中的首地址
        直接打印数组
    3. 获取数组中某个元素的地址
        打印&数组名[下标] // 获取数组中某个元素的地址，&是取址符
    4. 数组名是常量，不可以进行赋值的操作
*/

/*
冒泡排序
#include<iostring>
using namespace std;
int main(){
    int arr[5] = {5,4,3,2,1};
    int temp;
    for(i = 4; i >= 0; i--){
        for(j = 0; j < i; j++){
            if (arr[j] > arr[j+1]){
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
    system("pauls");
    return 0;
}
*/

/*
二维数组定义
    1. 数据类型 数组名[行数][列数];
    2. 数据类型 数组名[行数][列数] = { {数据1，数据2}， {数据3，数据4} }; //这个就是按照矩阵的方式来定义的，2列2行
    3. 数据类型 数组名[行数][列数] = { 数据1， 数据2， 数据3， 数据4 };  //自动按行填充
    4. 数据类型 数组名[][列数] = { 数据1， 数据2， 数据3， 数据4 }; //自动按行填充（可以省略行，但不允许省略列）
二维数组数组名
    1.查看数组占用内存空间
    2.打印二维数组首地址
*/

/*
函数 写在main的外面（上面）
函数的定义
    1.返回值类型 int/float/string/void(如果这个函数不需要返回值，对应的下面return;或者不写return)
    2.函数名
    3.参数表列 (int a, int b)
    4.函数体语句
    5.return表达式
函数的调用
    函数名（参数）
值传递  //函数调用的时候实参将数值传入给形参
    值传递时，如果形参发生改变，不会影响实参
函数的常见样式
    1.无参无返    void name(){}    ||    name();
    2.有参无返    void name(int a, int b){}    ||    name(a, b);
    3.无参有返    type name(){return type;}   ||    a = name();
    4.有参有返    type name(int a, int b){return type;}   ||    c = name(a, b);

函数的分文件编写 作用：让代码结构更清晰
    1.创建新的后缀名为.h的头文件
    2.创建新的后缀名为.cpp的源文件
    3.在头文件中写函数的声明   ->   void swap(int a,int b);  //函数声明
    4.在源文件中写函数的定义   ->   void swap(int a,int b){语句}  //函数定义
    5.关联头文件和源文件
        1.在源文件中引入头文件 #include "头文件名.h"
        2.在头文件中引入 #include<iostream>
                       using namespace std;
    6.在主文件中调用#include "头文件名.h"，即可使用里面包含的函数

函数传入数组时
    void name(int arr[], int len){} // 传入数组时，len是数组的长度, 用arr[]就可以
*/

/*
指针 可以通过指针间接访问内存
    1.内存编号从0开始，一般用16进制数字表示
    2.可以利用指针变量保存地址
定义指针
    数据类型 * 指针变量名; // int * p; 数据类型与要获取的数据的类型一致
    p = &a; // 赋值取变量a的地址
使用指针
    可以通过解引用的方式来找到指针指向的内存
    cout << *p << endl; // 指针前加*代表解引用，找到对应内存地址的数据
    *p = 1000; //可以通过*p访问并读写这个数据，赋值修改
指针所占内存空间
    在32位操作系统下，无论如何都占4个字节
    在64位操作系统下，指针所占内存空间是8个字节
    sizeof(int *) / sizeof(p) // 计算指针所占内存空间,float,double,long,char全是4个字节； x86是32位，x64是64位
空指针
    指针变量指向内存中编号为0的空间（内存编号的开头），用途当作初始化的指针值
    int * p = NULL; // NULL是空指针常量
        注意：空指针指向的内存是不可以访问的 （0-255的编号是系统占用内存，可以指向，但访问就报错【只要*p就报错】）
        *p = 1000; // 访问空指针的内存，报错
野指针
    指针变量指向非法的内存空间
    int * p = (int *)0x12345678; // 这个地址是非法的，不是自己申请的 || 0x12345678是一个数，加上(int *)就变成了一个地址
    *p就报错
*/

/*
const修饰指针
    1.const修饰指针 常量指针
        const int * p = &a; // 指针的指向可以修改，但指针指向的值不可以修改
        *p = 1000; // 报错，指针指向的值不可以修改
        p = &b; // 正确，可以修改指针的指向
    2.const修饰常量 指针常量
        int * const p = &a; // 指针的指向不可以修改，但指针指向的值可以修改
        *p = 1000; // 正确，可以修改指针指向的值
        p = &b; // 报错，指针的指向不可以修改
    3.const既修饰指针又修饰常量
        const int * const p = &a; // 指针的指向不可以修改，指针指向的值不可以修改
        *p = 1000; // 报错，指针指向的值不可以修改
        p = &b; // 报错，指针的指向不可以修改
*/

/*
指针和数组的配合使用
    利用指针访问数组中的元素
        指针访问arr的首地址后，因为是int型也就是4个字节，所以指针加1就会加4，直接指向下一个元素的地址
        int * p = arr; // 指针指向数组的首地址
        p++; //指针向后偏移4个字节
指针和函数的配合使用 （地址传递）
    指针作为函数的参数，可以修改实参的值，因为传递的不单是一个值了而是一个地址，而地址绑定了实参的值
    void name (int * p1, int * p2){
    }
    name(&a, &b); // 传递实参的地址，并以指针接受
指针数组函数
*/